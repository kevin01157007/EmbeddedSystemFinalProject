C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:03:31 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE HW3_PASSWORDLOCK
OBJECT MODULE PLACED IN .\hw3_PasswordLock.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\hw3_PasswordLock.c BROWSE DEBUG OBJECTEXTEND OBJECT(.\hw3_PasswordLock.o
                    -bj)

line level    source

   1          #include <reg52.h>
   2          #include <string.h>
   3          
   4          #define DataPort P0
   5          sbit LATCH1 = P2^2;
   6          sbit LATCH2 = P2^3;
   7          
   8          unsigned char code dofly_DuanMa[] = {
   9            0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
  10            0x77,0x7c,0x39,0x5e,0x79,0x71
  11          };
  12          unsigned char code dofly_WeiMa[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  13          unsigned char TempData[8];
  14          unsigned char password[4] = {1, 2, 3, 4};
  15          
  16          unsigned char uart_buf[10];
  17          unsigned char uart_index = 0;
  18          unsigned char uart_char;
  19          
  20          
  21          bit set_mode = 0;
  22          unsigned char input_index = 0;
  23          unsigned char input_buffer[4];
  24          
  25          // 函式宣告
  26          void Init_Timer0(void);
  27          void InitUART(void);
  28          void SendStr(unsigned char *s);
  29          void Display(unsigned char FirstBit, unsigned char Num);
  30          void DelayUs2x(unsigned char t);
  31          void DelayMs(unsigned char t);
  32          
  33          void main(void) {
  34   1          unsigned char i;
  35   1          Init_Timer0();
  36   1          InitUART();
  37   1          SendStr("8051 密碼鎖啟動...\r\n");
  38   1      
  39   1          while (1) {
  40   2              // 處理收到完整資料後的邏輯
  41   2              if (uart_index == 5) {
  42   3                              uart_buf[uart_index] = '\0';
  43   3                              uart_index = 0;
  44   3                  // 輸入為 ENTER
  45   3                  if (strcmp(uart_buf, "ENTER") == 0) {
  46   4                      bit correct = 1;
  47   4                      for (i = 0; i < 4; i++)
  48   4                          correct = correct && (input_buffer[i] == password[i]);
  49   4                      for (i = 0; i < 8; i++)
  50   4                          TempData[i] = 0;
  51   4                      if (correct) {
  52   5                          TempData[0] = 0x3f; // o
  53   5                          TempData[1] = 0x73; // p
  54   5                          TempData[2] = 0x79; // E
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:03:31 PAGE 2   

  55   5                          TempData[3] = 0x54; // n
  56   5                          SendStr("correct!");
  57   5                      } else {
  58   5                          TempData[0] = 0x79; // E
  59   5                          TempData[1] = 0x50; // r
  60   5                          TempData[2] = 0x50; // r
  61   5                          SendStr("wrong");
  62   5                      }
  63   4                      input_index = 0;
  64   4                  }
  65   3                  // 輸入為 SET
  66   3                  else if (strcmp(uart_buf, "SET\r\r") == 0) {
  67   4                      set_mode = 1;
  68   4                      input_index = 0;
  69   4                      SendStr("password_setup");
  70   4                  }
  71   3                  // 輸入為數字
  72   3                  else if (uart_buf[1] == '\r') {
  73   4                      unsigned char num = uart_buf[0] - '0';
  74   4                      if (set_mode) {
  75   5                          password[input_index] = num;
  76   5                          TempData[7 - input_index] = dofly_DuanMa[num];
  77   5                          input_index++;
  78   5                          if (input_index == 4) {
  79   6                              set_mode = 0;
  80   6                              input_index = 0;
  81   6                              SendStr("setup_finish");
  82   6                          }
  83   5                      } else {
  84   5                          input_buffer[input_index] = num;
  85   5                          TempData[7 - input_index] = dofly_DuanMa[num];
  86   5                          input_index++;
  87   5                          if (input_index >= 4)
  88   5                              input_index = 0;
  89   5                      }
  90   4                  }
  91   3                  // 清除緩衝
  92   3                  //uart_index = 0;
  93   3              }
  94   2          }
  95   1      }
  96          
  97          /*--------------------- 顯示函數 ---------------------*/
  98          void Display(unsigned char FirstBit,unsigned char Num) {
  99   1          static unsigned char i = 0;
 100   1          DataPort = 0;
 101   1          LATCH1 = 1; LATCH1 = 0;
 102   1          DataPort = dofly_WeiMa[i + FirstBit];
 103   1          LATCH2 = 1; LATCH2 = 0;
 104   1          DataPort = TempData[i];
 105   1          LATCH1 = 1; LATCH1 = 0;
 106   1          i++;
 107   1          if (i == Num) i = 0;
 108   1      }
 109          
 110          /*--------------------- 延時 ---------------------*/
 111          void DelayUs2x(unsigned char t) { while (--t); }
 112          void DelayMs(unsigned char t) {
 113   1          while (t--) {
 114   2              DelayUs2x(245);
 115   2              DelayUs2x(245);
 116   2          }
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:03:31 PAGE 3   

 117   1      }
 118          
 119          /*--------------------- Timer0 Init ---------------------*/
 120          void Init_Timer0(void) {
 121   1          TMOD |= 0x01;
 122   1          EA = 1;
 123   1          ET0 = 1;
 124   1          TR0 = 1;
 125   1      }
 126          void Timer0_isr(void) interrupt 1 {
 127   1          TH0 = (65536 - 2000) / 256;
 128   1          TL0 = (65536 - 2000) % 256;
 129   1          Display(0, 8);
 130   1      }
 131          
 132          /*--------------------- UART Init ---------------------*/
 133          void InitUART(void) {
 134   1          SCON = 0x50;
 135   1          TMOD |= 0x20;
 136   1          TH1 = 0xFD;
 137   1          TR1 = 1;
 138   1          ES = 1;
 139   1          EA = 1;
 140   1      }
 141          void SendByte(unsigned char dat) {
 142   1          SBUF = dat;
 143   1          while (!TI);
 144   1          TI = 0;
 145   1      }
 146          void SendStr(unsigned char *s) {
 147   1          while (*s) SendByte(*s++);
 148   1      }
 149          
 150          /*--------------------- UART 中斷處理 ---------------------*/
 151          void UART_SER (void) interrupt 4 //串行中斷服務程序
 152          {
 153   1          unsigned char Temp;          //定義臨時變量 
 154   1         
 155   1         if(RI)                        //判斷是接收中斷產生
 156   1           {
 157   2                      RI=0;                      //標誌位清零
 158   2                      Temp=SBUF;                 //讀入緩衝區的值
 159   2              //  P1=Temp;                   //把值輸出到P1口，用於觀察
 160   2          //  SBUF=Temp;                 //把接收到的值再發回電腦端
 161   2                      uart_buf[uart_index] = Temp;
 162   2                      uart_index++;
 163   2                      if (uart_index == 10) uart_index = 0;
 164   2               }
 165   1      //   if(TI)                        //如果是發送標誌位，清零
 166   1      //     TI=0;
 167   1      }
 168          
 169          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    499    ----
   CONSTANT SIZE    =    100    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30       4
   IDATA SIZE       =   ----    ----
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:03:31 PAGE 4   

   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
