C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:50:48 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE HW3_PASSWORDLOCK
OBJECT MODULE PLACED IN .\hw3_PasswordLock.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\hw3_PasswordLock.c BROWSE DEBUG OBJECTEXTEND OBJECT(.\hw3_PasswordLock.o
                    -bj)

line level    source

   1          #include <reg52.h>
   2          #include <string.h>
   3          
   4          #define DataPort P0
   5          sbit LATCH1 = P2^2;
   6          sbit LATCH2 = P2^3;
   7          
   8          unsigned char code dofly_DuanMa[] = {
   9            0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
  10            0x77,0x7c,0x39,0x5e,0x79,0x71
  11          };
  12          unsigned char code dofly_WeiMa[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  13          unsigned char TempData[8];
  14          unsigned char password[4] = {1, 2, 3, 4};
  15          
  16          unsigned char uart_buf[10];
  17          unsigned char uart_index = 0;
  18          unsigned char uart_char;
  19          
  20          
  21          bit set_mode = 0;
  22          unsigned char input_index = 0;
  23          unsigned char input_buffer[4];
  24          
  25          // 函式宣告
  26          void Init_Timer0(void);
  27          void InitUART(void);
  28          void SendStr(unsigned char *s);
  29          void Display(unsigned char FirstBit, unsigned char Num);
  30          void DelayUs2x(unsigned char t);
  31          void DelayMs(unsigned char t);
  32          
  33          void main(void) {
  34   1          unsigned char i;
  35   1              bit clear = 0;
  36   1          Init_Timer0();
  37   1          InitUART();
  38   1          SendStr("8051 密碼鎖啟動...\r\n");
  39   1      
  40   1          while (1) {
  41   2              // 判斷是否收到完整指令
  42   2              if (uart_index == 5) {
  43   3                  uart_buf[uart_index] = '\0';
  44   3                  uart_index = 0;
  45   3      
  46   3                  if (strcmp(uart_buf, "ENTER") == 0) {
  47   4                      bit correct = 1;
  48   4                      for (i = 0; i < 4; i++)
  49   4                          correct = correct && (input_buffer[i] == password[i]);
  50   4      
  51   4                      for (i = 0; i < 8; i++)
  52   4                          TempData[i] = 0;
  53   4      
  54   4                      if (correct) {
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:50:48 PAGE 2   

  55   5                          TempData[0] = 0x3f; // o
  56   5                          TempData[1] = 0x73; // p
  57   5                          TempData[2] = 0x79; // E
  58   5                          TempData[3] = 0x54; // n
  59   5                          SendStr("correct!");
  60   5                      } else {
  61   5                          TempData[0] = 0x79; // E
  62   5                          TempData[1] = 0x50; // r
  63   5                          TempData[2] = 0x50; // r
  64   5                          SendStr("wrong");
  65   5                      }
  66   4      
  67   4                                      clear = 1;
  68   4                      input_index = 0;
  69   4                  }
  70   3      
  71   3                  else if (strcmp(uart_buf, "SET\r\r") == 0) {
  72   4                      set_mode = 1;
  73   4                      input_index = 0;
  74   4                      for (i = 0; i < 8; i++)
  75   4                          TempData[i] = 0; // 進入設定模式先清除顯示
  76   4                      SendStr("password_setup");
  77   4                  }
  78   3      
  79   3                  else if (uart_buf[1] == '\r') {
  80   4      
  81   4                      unsigned char num = uart_buf[0] - '0';
  82   4      
  83   4                      // 輸入第一個數字時先清除顯示
  84   4                      if (input_index == 0 && clear == 1) {
  85   5                          for (i = 0; i < 8; i++)
  86   5                              TempData[i] = 0;
  87   5                      }
  88   4      
  89   4                      if (set_mode) {
  90   5                          password[input_index] = num;
  91   5                          TempData[7 - input_index] = dofly_DuanMa[num];
  92   5                          input_index++;
  93   5                          if (input_index == 4) {
  94   6                              set_mode = 0;
  95   6                              input_index = 0;
  96   6                              DelayMs(500); // 停留一點時間再清
  97   6                              for (i = 0; i < 8; i++)
  98   6                                  TempData[i] = 0;
  99   6                              SendStr("setup_finish");
 100   6                          }
 101   5                      } else {
 102   5                          input_buffer[input_index] = num;
 103   5                          TempData[4 + input_index] = dofly_DuanMa[num];
 104   5                          input_index++;
 105   5                          if (input_index >= 4)
 106   5                              input_index = 0;
 107   5                      }
 108   4                  }
 109   3              }
 110   2          }
 111   1      }
 112          
 113          /*--------------------- 顯示函數 ---------------------*/
 114          void Display(unsigned char FirstBit,unsigned char Num) {
 115   1          static unsigned char i = 0;
 116   1          DataPort = 0;
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:50:48 PAGE 3   

 117   1          LATCH1 = 1; LATCH1 = 0;
 118   1          DataPort = dofly_WeiMa[i + FirstBit];
 119   1          LATCH2 = 1; LATCH2 = 0;
 120   1          DataPort = TempData[i];
 121   1          LATCH1 = 1; LATCH1 = 0;
 122   1          i++;
 123   1          if (i == Num) i = 0;
 124   1      }
 125          
 126          /*--------------------- 延時 ---------------------*/
 127          void DelayUs2x(unsigned char t) { while (--t); }
 128          void DelayMs(unsigned char t) {
 129   1          while (t--) {
 130   2              DelayUs2x(245);
 131   2              DelayUs2x(245);
 132   2          }
 133   1      }
 134          
 135          /*--------------------- Timer0 Init ---------------------*/
 136          void Init_Timer0(void) {
 137   1          TMOD |= 0x01;
 138   1          EA = 1;
 139   1          ET0 = 1;
 140   1          TR0 = 1;
 141   1      }
 142          void Timer0_isr(void) interrupt 1 {
 143   1          TH0 = (65536 - 2000) / 256;
 144   1          TL0 = (65536 - 2000) % 256;
 145   1          Display(0, 8);
 146   1      }
 147          
 148          /*--------------------- UART Init ---------------------*/
 149          void InitUART(void) {
 150   1          SCON = 0x50;
 151   1          TMOD |= 0x20;
 152   1          TH1 = 0xFD;
 153   1          TR1 = 1;
 154   1          ES = 1;
 155   1          EA = 1;
 156   1      }
 157          void SendByte(unsigned char dat) {
 158   1          SBUF = dat;
 159   1          while (!TI);
 160   1          TI = 0;
 161   1      }
 162          void SendStr(unsigned char *s) {
 163   1          while (*s) SendByte(*s++);
 164   1      }
 165          
 166          /*--------------------- UART 中斷處理 ---------------------*/
 167          void UART_SER (void) interrupt 4 //串行中斷服務程序
 168          {
 169   1          unsigned char Temp;          //定義臨時變量 
 170   1         
 171   1         if(RI)                        //判斷是接收中斷產生
 172   1           {
 173   2                      RI=0;                      //標誌位清零
 174   2                      Temp=SBUF;                 //讀入緩衝區的值
 175   2              //  P1=Temp;                   //把值輸出到P1口，用於觀察
 176   2          //  SBUF=Temp;                 //把接收到的值再發回電腦端
 177   2                      uart_buf[uart_index] = Temp;
 178   2                      uart_index++;
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      05/27/2025 21:50:48 PAGE 4   

 179   2                      if (uart_index == 10) uart_index = 0;
 180   2               }
 181   1      //   if(TI)                        //如果是發送標誌位，清零
 182   1      //     TI=0;
 183   1      }
 184          
 185          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    574    ----
   CONSTANT SIZE    =    100    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
