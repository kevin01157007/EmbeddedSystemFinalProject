C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      06/02/2025 16:28:53 PAGE 1   


C51 COMPILER V7.08, COMPILATION OF MODULE HW3_PASSWORDLOCK
OBJECT MODULE PLACED IN .\hw3_PasswordLock.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\hw3_PasswordLock.c BROWSE DEBUG OBJECTEXTEND OBJECT(.\hw3_PasswordLock.o
                    -bj)

line level    source

   1          #include <reg52.h>
   2          #include <string.h>
   3          
   4          #define DataPort P0
   5          sbit LATCH1 = P2^2;
   6          sbit LATCH2 = P2^3;
   7          
   8          unsigned char code dofly_DuanMa[] = {
   9            0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
  10            0x77,0x7c,0x39,0x5e,0x79,0x71
  11          };
  12          unsigned char code dofly_WeiMa[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  13          unsigned char TempData[8];
  14          unsigned char password[4] = {1, 2, 3, 4};
  15          
  16          unsigned char uart_buf[10];
  17          unsigned char uart_index = 0;
  18          unsigned char uart_char;
  19          
  20          
  21          bit set_mode = 0;
  22          unsigned char input_index = 0;
  23          unsigned char input_buffer[4];
  24          
  25          // 函式宣告
  26          void Init_Timer0(void);
  27          void InitUART(void);
  28          void SendStr(unsigned char *s);
  29          void Display(unsigned char FirstBit, unsigned char Num);
  30          void DelayUs2x(unsigned char t);
  31          void DelayMs(unsigned char t);
  32          
  33          void main(void) {
  34   1          unsigned char i;
  35   1              bit clear = 0;
  36   1          Init_Timer0();
  37   1          InitUART();
  38   1          SendStr("8051 密碼鎖啟動...\r\n");
  39   1      
  40   1          while (1) {
  41   2              // 判斷是否收到完整指令
  42   2              if (uart_index == 5) {
  43   3                  uart_buf[uart_index] = '\0';
  44   3                  uart_index = 0;
  45   3      
  46   3                  if (strcmp(uart_buf, "ENTER") == 0) {
  47   4                                      if(set_mode) {
  48   5                                              for (i = 0; i < 8; i++)
  49   5                                      TempData[i] = 0;
  50   5                                              set_mode = 0;
  51   5                                              SendStr("setup_finish");
  52   5                                      }
  53   4                                      else {
  54   5                              bit correct = 1;
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      06/02/2025 16:28:53 PAGE 2   

  55   5                              for (i = 0; i < 4; i++)
  56   5                                  correct = correct && (input_buffer[i] == password[i]);
  57   5              
  58   5                              for (i = 0; i < 8; i++)
  59   5                                  TempData[i] = 0;
  60   5              
  61   5                              if (correct) {
  62   6                                  TempData[0] = 0x3f; // o
  63   6                                  TempData[1] = 0x73; // p
  64   6                                  TempData[2] = 0x79; // E
  65   6                                  TempData[3] = 0x54; // n
  66   6                                  SendStr("correct!");
  67   6                              } else {
  68   6                                  TempData[0] = 0x79; // E
  69   6                                  TempData[1] = 0x50; // r
  70   6                                  TempData[2] = 0x50; // r
  71   6                                  SendStr("wrong");
  72   6                              }
  73   5              
  74   5                                              clear = 1;
  75   5                              input_index = 0;
  76   5                                      }
  77   4                  }
  78   3      
  79   3                  else if (strcmp(uart_buf, "SET\r\r") == 0) {
  80   4                      set_mode = 1;
  81   4                      input_index = 0;
  82   4                      for (i = 0; i < 8; i++)
  83   4                          TempData[i] = 0; // 進入設定模式先清除顯示
  84   4                      SendStr("password_setup");
  85   4                  }
  86   3      
  87   3                  else if (uart_buf[1] == '\r') {
  88   4      
  89   4                      unsigned char num = uart_buf[0] - '0';
  90   4      
  91   4                      // 輸入第一個數字時先清除顯示
  92   4                      if (input_index == 0 && clear == 1) {
  93   5                          for (i = 0; i < 8; i++)
  94   5                              TempData[i] = 0;
  95   5                      }
  96   4      
  97   4                      if (set_mode) {
  98   5                          password[input_index] = num;
  99   5                          TempData[4 + input_index] = dofly_DuanMa[num];
 100   5                          input_index++;
 101   5                          if (input_index == 4) {
 102   6                              input_index = 0;
 103   6      
 104   6                          }
 105   5                      } else {
 106   5                          input_buffer[input_index] = num;
 107   5                          TempData[4 + input_index] = dofly_DuanMa[num];
 108   5                          input_index++;
 109   5                          if (input_index >= 4)
 110   5                              input_index = 0;
 111   5                      }
 112   4                  }
 113   3              }
 114   2          }
 115   1      }
 116          
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      06/02/2025 16:28:53 PAGE 3   

 117          /*--------------------- 顯示函數 ---------------------*/
 118          void Display(unsigned char FirstBit,unsigned char Num) {
 119   1          static unsigned char i = 0;
 120   1          DataPort = 0;
 121   1          LATCH1 = 1; LATCH1 = 0;
 122   1          DataPort = dofly_WeiMa[i + FirstBit];
 123   1          LATCH2 = 1; LATCH2 = 0;
 124   1          DataPort = TempData[i];
 125   1          LATCH1 = 1; LATCH1 = 0;
 126   1          i++;
 127   1          if (i == Num) i = 0;
 128   1      }
 129          
 130          /*--------------------- 延時 ---------------------*/
 131          void DelayUs2x(unsigned char t) { while (--t); }
 132          void DelayMs(unsigned char t) {
 133   1          while (t--) {
 134   2              DelayUs2x(245);
 135   2              DelayUs2x(245);
 136   2          }
 137   1      }
 138          
 139          /*--------------------- Timer0 Init ---------------------*/
 140          void Init_Timer0(void) {
 141   1          TMOD |= 0x01;
 142   1          EA = 1;
 143   1          ET0 = 1;
 144   1          TR0 = 1;
 145   1      }
 146          void Timer0_isr(void) interrupt 1 {
 147   1          TH0 = (65536 - 2000) / 256;
 148   1          TL0 = (65536 - 2000) % 256;
 149   1          Display(0, 8);
 150   1      }
 151          
 152          /*--------------------- UART Init ---------------------*/
 153          void InitUART(void) {
 154   1          SCON = 0x50;
 155   1          TMOD |= 0x20;
 156   1          TH1 = 0xFD;
 157   1          TR1 = 1;
 158   1          ES = 1;
 159   1          EA = 1;
 160   1      }
 161          void SendByte(unsigned char dat) {
 162   1          SBUF = dat;
 163   1          while (!TI);
 164   1          TI = 0;
 165   1      }
 166          void SendStr(unsigned char *s) {
 167   1          while (*s) SendByte(*s++);
 168   1      }
 169          
 170          /*--------------------- UART 中斷處理 ---------------------*/
 171          void UART_SER (void) interrupt 4 //串行中斷服務程序
 172          {
 173   1          unsigned char Temp;          //定義臨時變量 
 174   1         
 175   1         if(RI)                        //判斷是接收中斷產生
 176   1           {
 177   2                      RI=0;                      //標誌位清零
 178   2                      Temp=SBUF;                 //讀入緩衝區的值
C51 COMPILER V7.08   HW3_PASSWORDLOCK                                                      06/02/2025 16:28:53 PAGE 4   

 179   2              //  P1=Temp;                   //把值輸出到P1口，用於觀察
 180   2          //  SBUF=Temp;                 //把接收到的值再發回電腦端
 181   2                      uart_buf[uart_index] = Temp;
 182   2                      uart_index++;
 183   2                      if (uart_index == 10) uart_index = 0;
 184   2               }
 185   1      //   if(TI)                        //如果是發送標誌位，清零
 186   1      //     TI=0;
 187   1      }
 188          
 189          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    576    ----
   CONSTANT SIZE    =    100    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     30       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
